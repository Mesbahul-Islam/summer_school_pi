<!DOCTYPE html>
<html>
<head>
    <title>Sensor Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        
        h1 {
            text-align: center;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 40px;
        }
        
        .chart-container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            margin: 20px auto;
            padding: 20px;
            max-width: 900px;
            backdrop-filter: blur(10px);
            height: 400px; /* Fixed height for container */
            position: relative; /* For proper positioning */
        }
        
        .chart-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            max-width: 1800px;
            margin: 0 auto;
        }
        
        canvas { 
            border-radius: 10px;
            width: 100% !important;
            height: 320px !important; /* Fixed height accounting for title */
        }
        
        .group-title {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #555;
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-left: 8px;
        }
        
        .status-online {
            background-color: #10b981;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
        }
        
        .status-offline {
            background-color: #ef4444;
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);
        }
        
        .offline-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            padding: 20px;
            border-radius: 10px;
            border: 2px dashed #ef4444;
            font-weight: bold;
            text-align: center;
            z-index: 10;
        }
        
        .occupancy-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            padding: 20px 30px;
            z-index: 1000;
            min-width: 200px;
        }
        
        .occupancy-title {
            font-size: 1.1em;
            font-weight: bold;
            color: #555;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .occupancy-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .occupancy-occupied {
            color: #ef4444;
        }
        
        .occupancy-vacant {
            color: #10b981;
        }
        
        .occupancy-unknown {
            color: #6b7280;
        }
        
        .confidence-indicator {
            font-size: 0.9em;
            color: #6b7280;
            margin-top: 5px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>üöÄ Live Sensor Dashboard</h1>
    
    <!-- Occupancy Status Display -->
    <div class="occupancy-status" id="occupancy-status">
        <div class="occupancy-title">üè† Room Status</div>
        <div class="occupancy-indicator" id="occupancy-indicator">
            <span id="occupancy-text">Unknown</span>
        </div>
        <div class="confidence-indicator" id="confidence-indicator">
            Confidence: --
        </div>
    </div>
    
    <div class="chart-grid">
        <div class="chart-container" id="group3-distance-container">
            <div class="group-title">Group 3 - Distance Sensor <span class="status-indicator status-offline" id="group3-distance-status"></span></div>
            <canvas id="group3distanceChart"></canvas>
        </div>
        <div class="chart-container" id="group3-motion-container">
            <div class="group-title">Group 3 - Motion Sensor <span class="status-indicator status-offline" id="group3-motion-status"></span></div>
            <canvas id="group3motionChart"></canvas>
        </div>
        <div class="chart-container" id="group2-distance-container">
            <div class="group-title">Group 2 - Distance Sensor <span class="status-indicator status-offline" id="group2-distance-status"></span></div>
            <canvas id="group2distanceChart"></canvas>
        </div>
        <div class="chart-container" id="group2-motion-container">
            <div class="group-title">Group 2 - Motion Sensor <span class="status-indicator status-offline" id="group2-motion-status"></span></div>
            <canvas id="group2motionChart"></canvas>
        </div>
        <div class="chart-container" id="group1-distance-container">
            <div class="group-title">Group 1 - Distance Sensor <span class="status-indicator status-offline" id="group1-distance-status"></span></div>
            <canvas id="group1distanceChart"></canvas>
        </div>
        <div class="chart-container" id="group1-motion-container">
            <div class="group-title">Group 1 - Motion Sensor <span class="status-indicator status-offline" id="group1-motion-status"></span></div>
            <canvas id="group1motionChart"></canvas>
        </div>
    </div>

    <script>
    // Get contexts for all canvases
    const group3distanceCtx = document.getElementById('group3distanceChart').getContext('2d');
    const group3motionCtx = document.getElementById('group3motionChart').getContext('2d');
    const group2distanceCtx = document.getElementById('group2distanceChart').getContext('2d');
    const group2motionCtx = document.getElementById('group2motionChart').getContext('2d');
    const group1distanceCtx = document.getElementById('group1distanceChart').getContext('2d');
    const group1motionCtx = document.getElementById('group1motionChart').getContext('2d');

    // Enhanced chart creation helper
    const createLineChart = (ctx, label, borderColor, isMotion = false) => new Chart(ctx, {
        type: 'line',
        data: { 
            labels: [], 
            datasets: [{ 
                label,
                data: [],
                borderColor,
                backgroundColor: isMotion ? borderColor + '20' : borderColor + '15',
                fill: true,
                tension: isMotion ? 0 : 0.4,
                pointRadius: 5,
                pointHoverRadius: 8,
                pointBackgroundColor: borderColor,
                pointBorderColor: '#fff',
                pointBorderWidth: 2,
                stepped: isMotion ? 'before' : false,
                borderWidth: 3
            }] 
        },
        options: {
            responsive: true,
            maintainAspectRatio: false, // This allows the fixed height to work
            plugins: {
                legend: { 
                    display: true,
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        padding: 20,
                        font: { size: 14, weight: 'bold' }
                    }
                },
                tooltip: { 
                    enabled: true,
                    mode: 'index',
                    intersect: false,
                    backgroundColor: 'rgba(0,0,0,0.8)',
                    titleColor: '#fff',
                    bodyColor: '#fff',
                    borderColor: borderColor,
                    borderWidth: 2,
                    cornerRadius: 8,
                    displayColors: true
                }
            },
            scales: {
                x: {
                    grid: { 
                        display: true, 
                        color: 'rgba(0,0,0,0.1)',
                        drawBorder: false
                    },
                    ticks: {
                        maxTicksLimit: 8,
                        font: { size: 12 }
                    }
                },
                y: {
                    beginAtZero: true,
                    grid: { 
                        display: true, 
                        color: 'rgba(0,0,0,0.1)',
                        drawBorder: false
                    },
                    ticks: isMotion ? { 
                        stepSize: 1, 
                        max: 1.2, 
                        min: -0.2,
                        callback: function(value) {
                            return value === 1 ? 'Motion' : value === 0 ? 'No Motion' : '';
                        },
                        font: { size: 12 }
                    } : {
                        font: { size: 12 },
                        callback: function(value) {
                            return value + ' cm';
                        }
                    }
                }
            },
            animation: {
                duration: 750,
                easing: 'easeInOutQuart'
            }
        }
    });

    // Create charts with enhanced styling
    const group3distanceChart = createLineChart(group3distanceCtx, 'Distance (cm)', '#3b82f6', false);
    const group3motionChart = createLineChart(group3motionCtx, 'Motion Status', '#ef4444', true);

    const group2distanceChart = createLineChart(group2distanceCtx, 'Distance (cm)', '#10b981', false);
    const group2motionChart = createLineChart(group2motionCtx, 'Motion Status', '#f59e0b', true);

    const group1distanceChart = createLineChart(group1distanceCtx, 'Distance (cm)', '#8b5cf6', false);
    const group1motionChart = createLineChart(group1motionCtx, 'Motion Status', '#84cc16', true);

    // Remove this section - heights are now set in CSS
    // document.querySelectorAll('canvas').forEach(canvas => {
    //     canvas.style.height = '300px';
    // });

    // Maximum number of data points to keep
    const MAX_DATA_POINTS = 10;

    // Track last update times for offline detection
    const lastUpdateTimes = {
        group3Distance: 0,
        group3Motion: 0,
        group2Distance: 0,
        group2Motion: 0,
        group1Distance: 0,
        group1Motion: 0
    };

    // Offline threshold in milliseconds (5 seconds)
    const OFFLINE_THRESHOLD = 5000;

    function updateStatusIndicator(sensorId, isOnline) {
        const statusElement = document.getElementById(sensorId + '-status');
        if (statusElement) {
            statusElement.className = `status-indicator ${isOnline ? 'status-online' : 'status-offline'}`;
        }
    }

    function showOfflineMessage(containerId, show) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        let offlineMsg = container.querySelector('.offline-message');
        
        if (show && !offlineMsg) {
            offlineMsg = document.createElement('div');
            offlineMsg.className = 'offline-message';
            offlineMsg.innerHTML = 'üì° Device Offline<br><small>No data or null values received</small>';
            container.style.position = 'relative';
            container.appendChild(offlineMsg);
        } else if (!show && offlineMsg) {
            offlineMsg.remove();
        }
    }

    function checkOfflineStatus() {
        const now = Date.now();
        
        // Check each sensor
        const sensors = [
            { key: 'group3Distance', statusId: 'group3-distance', containerId: 'group3-distance-container' },
            { key: 'group3Motion', statusId: 'group3-motion', containerId: 'group3-motion-container' },
            { key: 'group2Distance', statusId: 'group2-distance', containerId: 'group2-distance-container' },
            { key: 'group2Motion', statusId: 'group2-motion', containerId: 'group2-motion-container' },
            { key: 'group1Distance', statusId: 'group1-distance', containerId: 'group1-distance-container' },
            { key: 'group1Motion', statusId: 'group1-motion', containerId: 'group1-motion-container' }
        ];

        sensors.forEach(sensor => {
            const isOnline = lastUpdateTimes[sensor.key] > 0 && (now - lastUpdateTimes[sensor.key]) < OFFLINE_THRESHOLD;
            updateStatusIndicator(sensor.statusId, isOnline);
            showOfflineMessage(sensor.containerId, !isOnline);
        });
    }

    function updateOccupancyStatus(occupancyData) {
        const occupancyText = document.getElementById('occupancy-text');
        const occupancyIndicator = document.getElementById('occupancy-indicator');
        const confidenceIndicator = document.getElementById('confidence-indicator');
        
        if (!occupancyData || occupancyData.occupancy === null || occupancyData.confidence === null) {
            occupancyText.textContent = 'Unknown';
            occupancyIndicator.className = 'occupancy-indicator occupancy-unknown';
            confidenceIndicator.textContent = 'Confidence: --';
            return;
        }
        
        const occupancyState = occupancyData.occupancy;
        const confidence = occupancyData.confidence;
        
        // Determine if confidence is high (assuming confidence is a percentage or 0-1 scale)
        const isHighConfidence = confidence > 0.7 || confidence > 70; // Support both 0-1 and 0-100 scales
        
        if (occupancyState === 'occupied' && isHighConfidence) {
            occupancyText.textContent = 'üî¥ OCCUPIED';
            occupancyIndicator.className = 'occupancy-indicator occupancy-occupied';
        } else if (occupancyState === 'vacant' || occupancyState === 'empty') {
            occupancyText.textContent = 'üü¢ VACANT';
            occupancyIndicator.className = 'occupancy-indicator occupancy-vacant';
        } else {
            occupancyText.textContent = 'üü° UNCERTAIN';
            occupancyIndicator.className = 'occupancy-indicator occupancy-unknown';
        }
        
        // Update confidence display
        const confidencePercent = confidence > 1 ? confidence : (confidence * 100);
        confidenceIndicator.textContent = `Confidence: ${confidencePercent.toFixed(1)}%`;
    }

    async function fetchData() {
        try {
            const response = await fetch("/data");
            const data = await response.json();

            const now = new Date().toLocaleTimeString();
            const currentTime = Date.now();

            function updateChart(chart, time, value, sensorKey, isMotion = false) {
                // Check if value is null - if so, mark sensor as offline
                if (value === null) {
                    lastUpdateTimes[sensorKey] = 0; // Mark as offline
                    return; // Don't add null data to chart
                }
                
                // Update last seen time for this sensor (only for valid data)
                lastUpdateTimes[sensorKey] = currentTime;
                
                // Add new data point
                chart.data.labels.push(time);
                chart.data.datasets[0].data.push(isMotion ? (value ? 1 : 0) : value || 0);
                
                // Remove oldest data points if we exceed the maximum
                if (chart.data.labels.length > MAX_DATA_POINTS) {
                    chart.data.labels.shift();
                    chart.data.datasets[0].data.shift();
                }
                
                chart.update('none'); // Use 'none' for better performance
            }

            // Update Group 3 charts
            if (data.group3) {
                if (data.group3.distance !== undefined) {
                    updateChart(group3distanceChart, data.group3.time || now, data.group3.distance, 'group3Distance');
                }
                if (data.group3.motion !== undefined) {
                    updateChart(group3motionChart, data.group3.time || now, data.group3.motion, 'group3Motion', true);
                }
            }

            // Update Group 2 charts (distance from ultrasonic, motion from pir)
            if (data.group2_ultrasonic && data.group2_ultrasonic.distance !== undefined) {
                updateChart(group2distanceChart, data.group2_ultrasonic.time || now, data.group2_ultrasonic.distance, 'group2Distance');
            }
            if (data.group2_pir && data.group2_pir.motion !== undefined) {
                updateChart(group2motionChart, data.group2_pir.time || now, data.group2_pir.motion, 'group2Motion', true);
            }

            // Update Group 1 charts
            if (data.group1) {
                if (data.group1.distance !== undefined) {
                    updateChart(group1distanceChart, now, data.group1.distance, 'group1Distance');
                }
                if (data.group1.motion !== undefined) {
                    updateChart(group1motionChart, now, data.group1.motion, 'group1Motion', true);
                }
            }

            // Update occupancy status
            if (data.occupancy) {
                updateOccupancyStatus(data.occupancy);
            }

            // Check for offline sensors
            checkOfflineStatus();

        } catch (err) {
            console.error("Failed to fetch or update sensor data:", err);
            // On fetch error, mark all sensors as potentially offline after threshold
            setTimeout(checkOfflineStatus, 1000);
        }
    }

    setInterval(fetchData, 1000);
    
    // Check offline status every 2 seconds
    setInterval(checkOfflineStatus, 2000);
    
    fetchData();
</script>

</body>
</html>